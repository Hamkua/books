## 프로그래머의 자유

### 클래스 작성자(class creator) 
클래스 작성자는 새로운 데이터 타입을 프로그램에 추가한다.

### 클라이언트 프로그래머(client programmer)
클래스 작성자가 추가한 데이터 타입을 사용한다.

### 구현 은닉(implementation hiding)
클래스 작성자는 클라이언트 프로그래미에게 필요한 부분만 공개하고 나머지는 꽁꽁 숨겨야 한다. 

클라이언트 프로그래머가 숨겨 놓은 부분에 마음대로 접근할 수 없도록 방지함으로써 클라이언트 프로그래머에 대한 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다. 이를 구현 은닉이라고 부른다.

## 객체로 변환
의미를 좀 더 명시적이고 분명하게 표현할 수 있다면 객체를 사용해서 해당 개념을 구현해라. 

그 개념이 비록 하나의 인스턴스 변수만 포함하더라도 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높일 수 있다.


## 컴파일 시간 의존성과 실행 시간 의존성

코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다.
유연하고, 쉽게 재사용할 수 있으며, 확장 가능한 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것이다.

문제는, 코드를 이해하기 위해서 객체를 생성하고, 연결하는 부분을 찾아야 하기 때문에, 코드의 의존성과 실행 시점의 의존성이 다를수록 코드를 이해하기 어려워진다는 것이다.

이런 의존성의 양면성은 설계가 트레이드오프의 산물이라는 것을 잘 보여줌.

## 상속의 단점

1. 캡슐화를 위반한다.

        부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다. 캡슐화의 약화는 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 변경될 가능성을 높인다.

2. 설계가 유연하지 않다.

        상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다. 따라서 실행 시점에 객체의 종류를 바꾸는 것이 불가능하다.


인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 **합성**이라고 한다.

합성은 상속의 문제점을 해결할 수 있다. 

인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다.

또한 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계가 유연해진다.

## 내 코드에 적용해보기

### 수정 전

기존 코드에 채팅방마다 소켓 연결 중인 WebSocketSession들을 보관하기 위해 `Map<Long, Set<WebSocketSession>> chatrooms` 를 사용했다.

``` java 
public class WebSocketHandler extends TextWebSocketHandler {

    ...

    private final ChatService chatService;

    private Map<Long, Set<WebSocketSession>> chatrooms;

    @PostConstruct
    private void init() {
        chatrooms = new LinkedHashMap<>();
    }

    ...
```

chatrooms는 두 메서드 내에서 사용된다.

1. 소켓 연결 직후, 해당 채팅방ID를 key로 하고, 기존 Set에 새롭게 연결된 WebSocketSession을 추가하는 경우

2. 소켓 연결을 끊을 때, 기존 Set에 연결을 끊으려는 WebSocketSession을 제거하는 경우


### 수정 후

``` java
public class Chatrooms {

    private Map<Long, Set<WebSocketSession>> chatrooms;

    public Chatrooms() {
        this.chatrooms = new HashMap<>();
    }

    public void put(Long chatroomId, Set<WebSocketSession> webSocketSessions){
        this.chatrooms.put(chatroomId, webSocketSessions);
    }

    public void put(Long chatroomId){
        this.chatrooms.put(chatroomId, new HashSet<WebSocketSession>());
    }

    public Set<WebSocketSession> get(Long chatroomId){
        return this.chatrooms.get(chatroomId);
    }

    public void remove(Long chatroomId){
        this.chatrooms.remove(chatroomId);
    }
}
```

Map으로 관리하던 채팅방을 객체로 변경했다.

일급 컬렉션의 형태가 되었다.

Map이라는 하나의 변수를 포함하지만 개념을 명시적으로 표현할 수 있게 되었다.

코드를 추가하면서 이후 검증 로직이 추가 된다면, 다른 클래스에 작성하지 않고 Chatroom.class가 자율적으로 검증할 수 있도록 할 것이다.

