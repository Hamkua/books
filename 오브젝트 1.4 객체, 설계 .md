### 캡슐화와 응집도

객체 내부의 상태를 캡슐화했다. 외부에 노출되는 부분을 분리하였고 이로 인해 Theater는 객체의 세부사항까지 알아야 하는 부담을 덜었다. 오직 메시지에 따른 메서드로 응답할 것이며, 원하는 결과를 반환할 것이라는 사실만이 남았다.

캡슐화를 통해 얻은 장점이 무엇일까? 생각해보자
내가 생각한 장점은 인터페이스, 즉 객체 간의 경계가 생겼다는 것이다. 그 경계 속에서 객체는 스스로 자신의 데이터를 책임져야 하는 자율적인 존재로 변화했다. 이것이 객체의 응집도를 높이는 결과로 이어졌다.

다시 말해 외부의 간섭을 최대한 배제하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것
하나의 객체에 집중된 책임을 여러 객체에 적절히 나누고 변경의 연쇄적인 전파가 객체 내부에서만 전파되는 것이 휼륭한 객체지향 설계의 지름길이라 생각한다.

### 절차지향과 객체지향

자바는 객체지향언어다. 하지만 언어의 패러다임, 특성을 끌어내지 못 한채 사용한다면 그것이 객체지향언어인 자바를 객체지향의 의도대로 사용한다고 말할 수 있을까?

초기 구조의 Theater클래스의 enter메서드는 **프로세스(Process)** 이며 Audience, TicketSeller, Bag, TicketOffice는 **데이터(Date)** 였다. 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 **절차적** 프로그래밍
이라 한다.

절차적 프로그래밍은 우리의 예상과는 다르게 enter 메서드를 통해 극장이 직접 고객의 가방을 열어 티켓을 확인하고 판매원을 통해 티켓판매소의 티켓 거래 처리하는 수동적인 상황이 연출되었다. 우리의 예상을 벗어난 결과로
인해 코드를 읽는 사람과 작성하는 본인 마저 의사소통에 문제가 있다.

또한 가장 큰 문제는 **변경의 연쇄적인 전파** 였다. 복잡한 의존성이 가져오는 응집도로 인해 하나의 변화가 코드 전체 구조를 수정해야 했었다.

⭐ **변경하기 쉬운 설계는 한 번에 하나의 클래스만 변경할 수 있는 설계다.**

절차적 프로그래밍은 **프로세스**(enter)가 필요한 모든 **데이터**(Audience, TicketSeller, Bag, TicketOffice)에 의존해야 한다는 근본적인 문제점 때문에 변경에 취약할 수밖에 없다.

반면 객체지향은 객체의 데이터를 사용하는 프로세스가 데이터를 소유하고 있는 객체 내부로 옮겼고 데이터와
프로세스가 동일한 모듈 내부에 위치하도록 변경하였다. 이를 통해 의존성은 적절히 통제되는 효과와 변경의 여파가 하나의 클래스 내부에서 발생하도록 억제되었다.

객체의 자율성을 통해 우리가 조금 더 이해할 수 있는 실제 **현실에 가까운 구조가 완성**되었고 기존 구조의 **의사소통 문제를 해결**하고 **변경에 있어 자유로운 구조**가 완성되었다.